# Automated PR review workflow using OpenAI API (GPT-5)
name: OpenAI PR Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

# Prevent duplicate runs on same PR
concurrency:
  group: openai-pr-review-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  review:
    runs-on: ubuntu-latest
    # Only run on PRs from the same repo (forks can't access secrets)
    if: github.event.pull_request.head.repo.full_name == github.repository

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Full history ensures merge base is always available for diff
          fetch-depth: 0

      - name: Compute diff
        id: diff
        run: |
          git diff origin/${{ github.base_ref }}...HEAD > diff.patch
          DIFF_LINES=$(wc -l < diff.patch)
          echo "Diff size: $DIFF_LINES lines, $(wc -c < diff.patch) bytes"

          # Check for empty diff
          if [ "$DIFF_LINES" -eq 0 ]; then
            echo "empty=true" >> $GITHUB_OUTPUT
            echo "No changes detected in diff"
          else
            echo "empty=false" >> $GITHUB_OUTPUT
          fi

      - name: Skip if empty diff
        if: steps.diff.outputs.empty == 'true'
        run: |
          echo "No code changes to review. Skipping API call."
          exit 0

      - name: Check API key
        if: steps.diff.outputs.empty != 'true'
        id: api_key_check
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "has_key=false" >> $GITHUB_OUTPUT
            echo "## OpenAI Code Review" > review.txt
            echo "" >> review.txt
            echo "OpenAI review skipped: no API key available for this PR context." >> review.txt
          else
            echo "has_key=true" >> $GITHUB_OUTPUT
          fi

      - name: Fetch previous OpenAI reviews from PR
        if: steps.diff.outputs.empty != 'true' && steps.api_key_check.outputs.has_key == 'true'
        id: previous_openai
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Use gh CLI to fetch comments (simpler than curl)
          echo "Fetching comments from PR #${{ github.event.pull_request.number }}..."

          # Use precise marker "## OpenAI Code Review" to avoid false matches
          gh api "repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments" \
            --jq '[.[] | select((.user.login == "github-actions[bot]" or .user.login == "github-actions") and (.body | contains("## OpenAI Code Review")))] | last | .body // empty' \
            > previous_openai_review.txt

          # Also capture comment ID for later update
          gh api "repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments" \
            --jq '[.[] | select((.user.login == "github-actions[bot]" or .user.login == "github-actions") and (.body | contains("## OpenAI Code Review")))] | last | .id // empty' \
            > previous_comment_id.txt

          if [ -s previous_openai_review.txt ]; then
            REVIEW_SIZE=$(wc -c < previous_openai_review.txt)
            echo "Found previous OpenAI review ($REVIEW_SIZE bytes)"
            echo "has_previous_openai=true" >> $GITHUB_OUTPUT
          else
            echo "No previous OpenAI review found on this PR"
            echo "has_previous_openai=false" >> $GITHUB_OUTPUT
          fi

      - name: Build prompt
        if: steps.diff.outputs.empty != 'true' && steps.api_key_check.outputs.has_key == 'true'
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
          REPO_NAME: ${{ github.repository }}
          BRANCH_NAME: ${{ github.head_ref }}
          HAS_PREVIOUS_OPENAI: ${{ steps.previous_openai.outputs.has_previous_openai }}
        run: |
          # Configuration
          # Max diff size in lines - truncate by lines for clean breaks
          MAX_DIFF_LINES=1500
          MAX_PREVIOUS_OPENAI_LINES=200

          cat > system_prompt.txt << 'EOF'
          You are an expert code reviewer analyzing a pull request. Your reviews are thorough, constructive, and focus on code quality, potential bugs, and best practices.

          When reviewing:
          - Be specific and actionable in your feedback
          - Prioritize important issues over minor style preferences
          - Acknowledge good practices when you see them
          - Consider security implications
          - Think about maintainability and readability

          Format your response as markdown suitable for a GitHub PR comment.
          EOF

          cat > user_prompt.txt << 'EOF'
          EOF

          # Sanitize and add PR metadata
          echo "# Pull Request Review Request" >> user_prompt.txt
          echo "" >> user_prompt.txt
          echo "**Pull Request Title:** $PR_TITLE" >> user_prompt.txt
          echo "**Repository:** $REPO_NAME" >> user_prompt.txt
          echo "**Branch:** $BRANCH_NAME" >> user_prompt.txt
          echo "" >> user_prompt.txt

          # Include previous OpenAI review from this PR (your own previous feedback)
          if [ "$HAS_PREVIOUS_OPENAI" = "true" ] && [ -s previous_openai_review.txt ]; then
            echo "## Your Previous Review on This PR" >> user_prompt.txt
            echo "" >> user_prompt.txt
            echo "You already posted a review on this PR. The code has been updated since then." >> user_prompt.txt
            echo "Use this to:" >> user_prompt.txt
            echo "- Acknowledge issues that were FIXED in the new diff" >> user_prompt.txt
            echo "- Avoid repeating feedback that still applies but hasn't changed" >> user_prompt.txt
            echo "- Focus on NEW changes since your last review" >> user_prompt.txt
            echo "" >> user_prompt.txt
            echo "Your previous review (truncated if large):" >> user_prompt.txt
            echo '```markdown' >> user_prompt.txt
            head -n "$MAX_PREVIOUS_OPENAI_LINES" previous_openai_review.txt >> user_prompt.txt
            echo '' >> user_prompt.txt
            echo '```' >> user_prompt.txt
            echo "" >> user_prompt.txt
          fi

          cat >> user_prompt.txt << 'EOF'

          ## Review Instructions

          Please analyze the diff below and provide:
          1. **Potential bugs or regressions** - Consider how these changes interact with the existing codebase
          2. **Style or readability issues** - Code quality and maintainability concerns
          3. **Concrete suggestions for improvement** - Specific, actionable recommendations
          4. **Security concerns** - Any potential vulnerabilities introduced

          **IMPORTANT RULES:**
          - If you posted a previous review, start with "## Updates Since Last Review" acknowledging what was fixed
          - Focus on genuinely NEW issues or unresolved concerns
          - If everything looks good now, say so briefly
          - Start your review with "## OpenAI Code Review" as the header

          ## Git Diff

          ```diff
          EOF

          # Truncate diff by lines for clean breaks (not bytes which can corrupt)
          DIFF_LINES="$(wc -l < diff.patch 2>/dev/null || echo 0)"
          if [ "$DIFF_LINES" -gt "$MAX_DIFF_LINES" ]; then
            echo "" >> user_prompt.txt
            echo "Note: The diff has been truncated to ${MAX_DIFF_LINES} lines due to size limits." >> user_prompt.txt
            echo "" >> user_prompt.txt
            head -n "$MAX_DIFF_LINES" diff.patch >> user_prompt.txt
          else
            cat diff.patch >> user_prompt.txt
          fi

          cat >> user_prompt.txt << 'EOF'
          ```
          EOF

      - name: Call OpenAI API
        if: steps.diff.outputs.empty != 'true' && steps.api_key_check.outputs.has_key == 'true'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set +x  # Prevent API key from appearing in logs

          SYSTEM_PROMPT=$(cat system_prompt.txt | jq -Rs . 2>/dev/null)
          USER_PROMPT=$(cat user_prompt.txt | jq -Rs . 2>/dev/null)

          if [ -z "$SYSTEM_PROMPT" ] || [ -z "$USER_PROMPT" ]; then
            echo "## OpenAI Code Review" > review.txt
            echo "" >> review.txt
            echo "Failed to prepare prompts. Check prompt file formatting." >> review.txt
            exit 1
          fi

          # GPT-5 is a reasoning model - temperature is fixed at 1 (not configurable)
          # Needs high max_completion_tokens because reasoning tokens count against the limit
          PAYLOAD=$(cat <<EOF
          {
            "model": "gpt-5",
            "messages": [
              {"role": "system", "content": $SYSTEM_PROMPT},
              {"role": "user", "content": $USER_PROMPT}
            ],
            "max_completion_tokens": 49152
          }
          EOF
          )

          echo "Calling OpenAI API (GPT-5)..."

          # Retry logic for transient errors (timeout, 429, 5xx)
          MAX_RETRIES=3
          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $attempt of $MAX_RETRIES..."

            HTTP_CODE=$(curl -s \
              --connect-timeout 30 \
              --max-time 300 \
              -w "%{http_code}" \
              -o openai_response.json \
              -X POST \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -d "$PAYLOAD" \
              https://api.openai.com/v1/chat/completions)

            CURL_EXIT=$?

            echo "HTTP Status: $HTTP_CODE, Curl exit: $CURL_EXIT"

            # Check for transient errors that warrant retry
            if [ "$CURL_EXIT" -eq 28 ] || [ "$HTTP_CODE" = "429" ] || [ "$HTTP_CODE" = "500" ] || [ "$HTTP_CODE" = "502" ] || [ "$HTTP_CODE" = "503" ]; then
              if [ "$attempt" -lt "$MAX_RETRIES" ]; then
                SLEEP_TIME=$((attempt * 10))
                echo "Transient error, retrying in ${SLEEP_TIME}s..."
                sleep $SLEEP_TIME
                continue
              fi
            fi
            break
          done

          # Handle timeout errors (exit code 28) after all retries
          if [ "$CURL_EXIT" -eq 28 ]; then
            echo "Error: API request timed out after all retries"
            echo "## OpenAI Code Review" > review.txt
            echo "" >> review.txt
            echo "The OpenAI GPT-5 API took too long to respond. Please retry the workflow." >> review.txt
            exit 1
          fi

          # Handle other curl errors
          if [ "$CURL_EXIT" -ne 0 ]; then
            echo "Error: Curl failed with exit code $CURL_EXIT"
            echo "## OpenAI Code Review" > review.txt
            echo "" >> review.txt
            echo "Failed to connect to OpenAI API. Please retry the workflow." >> review.txt
            exit 1
          fi

          if [ "$HTTP_CODE" != "200" ]; then
            # Extract just the error message, not full response (reduces log verbosity)
            ERROR_MSG=$(jq -r '.error.message // "Unknown error"' openai_response.json 2>/dev/null || echo "Unknown error")
            echo "Error: OpenAI API returned status $HTTP_CODE - $ERROR_MSG"

            # Build error message based on HTTP status
            echo "## OpenAI Code Review" > review.txt
            echo "" >> review.txt
            if [ "$HTTP_CODE" == "429" ]; then
              echo "Rate limit exceeded. Please check your API quota at https://platform.openai.com/usage" >> review.txt
            elif [ "$HTTP_CODE" == "401" ]; then
              echo "Authentication failed. Please verify OPENAI_API_KEY secret is configured correctly." >> review.txt
            elif [ "$HTTP_CODE" == "403" ]; then
              echo "Access denied. Please check your API key permissions and organization settings." >> review.txt
            elif [ "$HTTP_CODE" == "500" ] || [ "$HTTP_CODE" == "502" ] || [ "$HTTP_CODE" == "503" ]; then
              echo "OpenAI service is temporarily unavailable (HTTP $HTTP_CODE). Please retry the workflow." >> review.txt
            else
              echo "API call failed (HTTP $HTTP_CODE): $ERROR_MSG" >> review.txt
            fi

            exit 1
          fi

          # Parse response with error handling
          if ! jq -e '.choices[0].message.content' openai_response.json > /dev/null 2>&1; then
            echo "## OpenAI Code Review" > review.txt
            echo "" >> review.txt
            echo "OpenAI API returned an unexpected response format. Response:" >> review.txt
            cat openai_response.json >> review.txt
            exit 1
          fi

          jq -r '.choices[0].message.content' openai_response.json > review.txt

          # Check for meaningful content (not just whitespace/newlines)
          REVIEW_CONTENT=$(cat review.txt | tr -d '[:space:]')
          if [ -z "$REVIEW_CONTENT" ]; then
            # Log finish_reason for debugging (not full response)
            FINISH_REASON=$(jq -r '.choices[0].finish_reason // "unknown"' openai_response.json 2>/dev/null)
            REASONING_TOKENS=$(jq -r '.usage.completion_tokens_details.reasoning_tokens // 0' openai_response.json 2>/dev/null)
            echo "Warning: Empty content. finish_reason=$FINISH_REASON, reasoning_tokens=$REASONING_TOKENS"

            echo "## OpenAI Code Review" > review.txt
            echo "" >> review.txt
            echo "OpenAI returned no content (finish_reason: $FINISH_REASON). This may indicate the model used all tokens for reasoning." >> review.txt
            echo "" >> review.txt
            echo "Please retry the workflow." >> review.txt
            exit 1
          fi

          echo "Review generated successfully ($(wc -c < review.txt) bytes)"
          echo "Preview:"
          head -n 10 review.txt

      - name: Post or update review comment
        # Run even if API call failed (to post error messages)
        if: always() && steps.diff.outputs.empty != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Preparing to post review comment..."

          # Check for meaningful content (not just whitespace)
          if [ ! -f review.txt ]; then
            echo "Review file not found, skipping comment."
            exit 0
          fi

          CONTENT=$(cat review.txt | tr -d '[:space:]')
          if [ -z "$CONTENT" ]; then
            echo "Review is empty or whitespace-only, skipping comment."
            exit 0
          fi

          echo "Review content length: $(wc -c < review.txt) bytes"

          PR_NUMBER=${{ github.event.pull_request.number }}

          # Check if we have a previous comment ID to update
          COMMENT_ID=""
          if [ -f previous_comment_id.txt ]; then
            COMMENT_ID=$(cat previous_comment_id.txt | tr -d '[:space:]')
          fi

          if [ -n "$COMMENT_ID" ]; then
            echo "Updating existing comment $COMMENT_ID..."
            gh api -X PATCH "repos/${{ github.repository }}/issues/comments/$COMMENT_ID" \
              -f body="$(cat review.txt)" && echo "Comment updated successfully!" || {
              echo "Failed to update, posting new comment..."
              gh pr comment $PR_NUMBER --body-file review.txt
            }
          else
            echo "Posting new comment to PR #$PR_NUMBER..."
            gh pr comment $PR_NUMBER --body-file review.txt
            echo "Comment posted successfully!"
          fi
