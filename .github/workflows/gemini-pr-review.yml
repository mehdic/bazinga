# Automated PR review workflow using Gemini API
name: Gemini PR Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  review:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 20

      - name: Compute diff
        run: |
          git fetch origin ${{ github.base_ref }}
          # Exclude package-lock.json (large, auto-generated) from review diff
          git diff origin/${{ github.base_ref }}...HEAD -- . ':!**/package-lock.json' > diff.patch

      - name: Fetch previous Gemini reviews from PR
        id: previous_gemini
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Fetch previous review comments from this PR posted by github-actions bot
          # This ensures Gemini has context from its own previous reviews
          echo "Fetching comments from PR #${{ github.event.pull_request.number }}..."

          curl -s \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments" \
            -o pr_comments.json

          # Filter for github-actions bot comments (Gemini reviews)
          # Get the most recent one (last in the array after filtering)
          jq -r '[.[] | select(.user.login == "github-actions[bot]" or .user.login == "github-actions")] | last | .body // empty' pr_comments.json > previous_gemini_review.txt

          if [ -s previous_gemini_review.txt ]; then
            REVIEW_SIZE=$(wc -c < previous_gemini_review.txt)
            echo "Found previous Gemini review ($REVIEW_SIZE bytes)"
            echo "has_previous_gemini=true" >> $GITHUB_OUTPUT
          else
            echo "No previous Gemini review found on this PR"
            echo "has_previous_gemini=false" >> $GITHUB_OUTPUT
          fi

      - name: Fetch responses to reviews (explains fixed/skipped items)
        id: review_responses
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Fetch ALL PR comments to find responses explaining what was done
          # These responses (posted by humans or Claude) explain which items were
          # implemented vs skipped and why
          echo "Fetching review responses from PR #${{ github.event.pull_request.number }}..."

          # Look for comments containing response markers (✅ Fixed, ⏭️ Skipped, Response to Review)
          jq -r '[.[] | select(.body | (contains("✅") or contains("⏭️") or contains("Response to Review") or contains("Fixed in commit") or contains("Skipped -")))] | .[] | "--- Response from \(.user.login) at \(.created_at) ---\n\(.body)\n"' pr_comments.json > review_responses.txt

          if [ -s review_responses.txt ]; then
            RESP_SIZE=$(wc -c < review_responses.txt)
            echo "Found review responses ($RESP_SIZE bytes)"
            echo "has_responses=true" >> $GITHUB_OUTPUT
          else
            echo "No review responses found"
            echo "has_responses=false" >> $GITHUB_OUTPUT
          fi

      - name: Build prompt
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
          REPO_NAME: ${{ github.repository }}
          BRANCH_NAME: ${{ github.head_ref }}
          HAS_PREVIOUS_GEMINI: ${{ steps.previous_gemini.outputs.has_previous_gemini }}
          HAS_RESPONSES: ${{ steps.review_responses.outputs.has_responses }}
        run: |
          # Configuration
          # Max diff size in characters - Gemini API has token limits
          # 40k chars ≈ 10k tokens, leaving headroom for prompt + response
          MAX_DIFF_SIZE=40000
          MAX_PREVIOUS_GEMINI_SIZE=8000
          MAX_RESPONSES_SIZE=6000

          cat > prompt_header.txt << 'EOF'
          You are an expert code reviewer analyzing a pull request.

          EOF

          # Sanitize and add PR metadata
          echo "Pull Request Title: $PR_TITLE" >> prompt_header.txt
          echo "Repository: $REPO_NAME" >> prompt_header.txt
          echo "Branch: $BRANCH_NAME" >> prompt_header.txt
          echo "" >> prompt_header.txt

          # Include previous Gemini review from this PR (your own previous feedback)
          if [ "$HAS_PREVIOUS_GEMINI" = "true" ] && [ -s previous_gemini_review.txt ]; then
            echo "## Your Previous Review on This PR" >> prompt_header.txt
            echo "" >> prompt_header.txt
            echo "You already posted a review on this PR. The code has been updated since then." >> prompt_header.txt
            echo "Use this to:" >> prompt_header.txt
            echo "- Acknowledge issues that were FIXED in the new diff" >> prompt_header.txt
            echo "- Avoid repeating feedback that still applies but hasn't changed" >> prompt_header.txt
            echo "- Focus on NEW changes since your last review" >> prompt_header.txt
            echo "" >> prompt_header.txt
            echo "Your previous review (truncated if large):" >> prompt_header.txt
            echo '```markdown' >> prompt_header.txt
            head -c "$MAX_PREVIOUS_GEMINI_SIZE" previous_gemini_review.txt >> prompt_header.txt
            echo '' >> prompt_header.txt
            echo '```' >> prompt_header.txt
            echo "" >> prompt_header.txt
          fi

          # Include responses explaining what was fixed/skipped
          if [ "$HAS_RESPONSES" = "true" ] && [ -s review_responses.txt ]; then
            echo "## Responses to Review Feedback" >> prompt_header.txt
            echo "" >> prompt_header.txt
            echo "The developer posted responses explaining which issues were addressed:" >> prompt_header.txt
            echo "- ✅ = Fixed/Implemented" >> prompt_header.txt
            echo "- ⏭️ = Intentionally skipped (with explanation)" >> prompt_header.txt
            echo "" >> prompt_header.txt
            echo "Use these responses to:" >> prompt_header.txt
            echo "- NOT re-raise issues that were explained as intentional/by-design" >> prompt_header.txt
            echo "- Verify claimed fixes actually appear in the new diff" >> prompt_header.txt
            echo "- Focus only on genuinely NEW issues" >> prompt_header.txt
            echo "" >> prompt_header.txt
            echo "Responses:" >> prompt_header.txt
            echo '```' >> prompt_header.txt
            head -c "$MAX_RESPONSES_SIZE" review_responses.txt >> prompt_header.txt
            echo '' >> prompt_header.txt
            echo '```' >> prompt_header.txt
            echo "" >> prompt_header.txt
          fi

          cat >> prompt_header.txt << 'EOF'
          NOTE: You are provided with the complete Git diff below. Use this diff to understand all changes in this PR.

          Please analyze the diff and provide:
          1. Potential bugs or regressions - Consider how these changes interact with the existing codebase
          2. Style or readability issues - Code quality and maintainability concerns
          3. Concrete suggestions for improvement - Specific, actionable recommendations

          IMPORTANT RULES:
          - If you posted a previous review, start with "## Updates Since Last Review" acknowledging what was fixed
          - Focus on genuinely NEW issues or unresolved concerns
          - If everything looks good now, say so briefly

          Format your response as a concise, markdown-formatted code review suitable for posting as a PR comment.

          Below is the Git diff of the changes:

          ```diff
          EOF

          # Truncate diff if too large (with safe command substitution)
          DIFF_SIZE="$(wc -c < diff.patch 2>/dev/null || echo 0)"
          if [ "$DIFF_SIZE" -gt "$MAX_DIFF_SIZE" ]; then
            echo "" >> prompt_header.txt
            echo "⚠️ Note: The diff has been truncated to ${MAX_DIFF_SIZE} characters due to size limits." >> prompt_header.txt
            echo "" >> prompt_header.txt
            head -c "$MAX_DIFF_SIZE" diff.patch >> prompt_header.txt
          else
            cat diff.patch >> prompt_header.txt
          fi

          cat >> prompt_header.txt << 'EOF'
          ```
          EOF

      - name: Call Gemini API
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          set +x  # Prevent API key from appearing in logs

          PROMPT=$(cat prompt_header.txt | jq -Rs . 2>/dev/null)
          if [ -z "$PROMPT" ]; then
            echo "⚠️ Failed to prepare prompt. Check prompt_header.txt formatting." > review.txt
            exit 0
          fi

          PAYLOAD=$(cat <<EOF
          {
            "contents": [{
              "parts": [{"text": $PROMPT}]
            }]
          }
          EOF
          )

          echo "Calling Gemini API..."

          # Save response to file with extended timeout for Gemini 3 Pro
          # --connect-timeout 30: Allow 30s to establish connection
          # --max-time 210: Allow 3.5 minutes for complete response (Gemini 3 Pro can be slow)
          HTTP_CODE=$(curl -s \
            --connect-timeout 30 \
            --max-time 210 \
            -w "%{http_code}" \
            -o gemini_response.json \
            -X POST \
            -H "Content-Type: application/json" \
            -H "x-goog-api-key: $GEMINI_API_KEY" \
            -d "$PAYLOAD" \
            https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent)

          CURL_EXIT=$?

          echo "HTTP Status: $HTTP_CODE"
          echo "Curl exit code: $CURL_EXIT"

          # Handle timeout errors (exit code 28)
          if [ "$CURL_EXIT" -eq 28 ]; then
            echo "Error: API request timed out after 210 seconds"
            echo "## ⚠️ Gemini API Timeout" > review.txt
            echo "" >> review.txt
            echo "The Gemini 3 Pro model took too long to respond (greater than 3.5 minutes). This can happen with large diffs or complex analysis." >> review.txt
            echo "" >> review.txt
            echo "**Suggestions:**" >> review.txt
            echo "- Try reducing the diff size" >> review.txt
            echo "- Use a faster model (e.g., gemini-2.5-flash)" >> review.txt
            echo "- Retry the workflow" >> review.txt
            exit 0
          fi

          # Handle other curl errors
          if [ "$CURL_EXIT" -ne 0 ]; then
            echo "Error: Curl failed with exit code $CURL_EXIT"
            echo "## ⚠️ Network Error" > review.txt
            echo "" >> review.txt
            echo "Failed to connect to Gemini API (curl exit code: $CURL_EXIT)." >> review.txt
            echo "" >> review.txt
            echo "**Please check:**" >> review.txt
            echo "- Network connectivity" >> review.txt
            echo "- API endpoint availability" >> review.txt
            echo "- Retry the workflow" >> review.txt
            exit 0
          fi

          if [ "$HTTP_CODE" != "200" ]; then
            echo "Error: Gemini API returned status $HTTP_CODE"
            cat gemini_response.json

            # Build error message based on HTTP status
            if [ "$HTTP_CODE" == "429" ]; then
              echo "## ⚠️ Gemini API Error (HTTP $HTTP_CODE)" > review.txt
              echo "" >> review.txt
              echo "Rate limit exceeded. Please check your API quota at https://aistudio.google.com/app/apikey" >> review.txt
            elif [ "$HTTP_CODE" == "401" ] || [ "$HTTP_CODE" == "403" ]; then
              echo "## ⚠️ Gemini API Error (HTTP $HTTP_CODE)" > review.txt
              echo "" >> review.txt
              echo "Authentication failed. Please verify GEMINI_API_KEY secret is configured correctly." >> review.txt
            else
              echo "## ⚠️ Gemini API Error (HTTP $HTTP_CODE)" > review.txt
              echo "" >> review.txt
              echo "API call failed. Check workflow logs for details." >> review.txt
            fi

            exit 0
          fi

          # Parse response with error handling
          if ! jq -e '.candidates[0].content.parts[0].text' gemini_response.json > /dev/null 2>&1; then
            echo "⚠️ Gemini API returned an unexpected response format. Response:" > review.txt
            cat gemini_response.json >> review.txt
            exit 0
          fi

          jq -r '.candidates[0].content.parts[0].text' gemini_response.json > review.txt

          if [ ! -s review.txt ]; then
            echo "⚠️ Review file is empty. Gemini may have returned no content." > review.txt
            exit 0
          fi

          echo "Review generated successfully ($(wc -c < review.txt) bytes)"
          echo "Preview:"
          head -n 10 review.txt

      - name: Post review comment
        # Run even if API call failed (to post error messages)
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Preparing to post review comment..."

          if [ ! -f review.txt ]; then
            echo "Review file not found, skipping comment."
            exit 0
          fi

          # Check for meaningful content (not just whitespace)
          CONTENT=$(cat review.txt | tr -d '[:space:]')
          if [ -z "$CONTENT" ]; then
            echo "Review is empty or whitespace-only, skipping comment."
            exit 0
          fi

          REVIEW_SIZE="$(wc -c < review.txt)"
          echo "Review content length: $REVIEW_SIZE bytes"

          # Add prefix to distinguish from OpenAI reviews
          echo "## Gemini Review" > prefixed_review.txt
          echo "" >> prefixed_review.txt
          cat review.txt >> prefixed_review.txt

          PR_NUMBER=${{ github.event.pull_request.number }}
          echo "Posting comment to PR #$PR_NUMBER..."

          gh pr comment $PR_NUMBER --body-file prefixed_review.txt
          echo "Comment posted successfully!"
